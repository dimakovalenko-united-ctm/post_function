#!/usr/bin/env python
"""
Test suite for security constraints in the crypto pricing service.
Tests verify that users cannot provide or manipulate internal fields like:
1. id (should be generated by the system)
2. is_deleted (should be controlled by the system)
3. insertion_timestamp (should be generated by the system)
"""

import pytest
import json
import uuid
from unittest.mock import patch, MagicMock
from datetime import datetime, timezone, timedelta

# Add the project root to the Python path if needed
import os
import sys
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, project_root)

# Import necessary modules
from main import app, publish_message_to_pubsub
from common.models.http_query_params import PostData
from fastapi.testclient import TestClient

# Create test client
client = TestClient(app)

class TestSecurityConstraints:
    """Test security constraints for protected fields."""

    def setup_method(self):
        """Setup for each test."""
        self.valid_base_data = {
            "crypto_name": "Bitcoin",
            "crypto_symbol": "BTC",
            "fiat_currency": "USD",
            "source": "test-api",
            "open": 50000.0,
            "close": 51000.0,
            "high": 52000.0,
            "low": 49000.0,
            "volume": 1000.0,
            "ticker": "BTC-USD",
            "timestamp": datetime.now(timezone.utc).isoformat()
        }

    @patch('google.cloud.pubsub_v1.PublisherClient')
    def test_user_provided_id_ignored(self, mock_publisher_class):
        """Test that user-provided 'id' field is ignored and a new one is generated."""
        # Setup mock
        mock_publisher = mock_publisher_class.return_value
        mock_publisher.topic_path.return_value = "projects/test-project/topics/test-topic"
        
        mock_future = MagicMock()
        mock_future.result.return_value = "test-message-id"
        mock_publisher.publish.return_value = mock_future
        
        # Create user-provided ID
        user_provided_id = "user-provided-id-12345"
        
        # Add ID to request data
        test_data = {**self.valid_base_data, "id": user_provided_id}
        
        # Make API request
        response = client.post("/prices", json=[test_data])
        
        # Verify successful response
        assert response.status_code == 201
        
        # Get response data
        response_data = response.json()
        
        # Verify the ID in the response is not the user-provided one
        assert len(response_data["data"]) == 1
        assert "id" in response_data["data"][0]
        assert response_data["data"][0]["id"] != user_provided_id
        
        # Verify the ID sent to Pub/Sub is not the user-provided one
        publish_call = mock_publisher.publish.call_args
        published_data = json.loads(publish_call[0][1].decode('utf-8'))
        
        assert "id" in published_data
        assert published_data["id"] != user_provided_id
        
        # Verify the generated ID is a valid UUID
        try:
            uuid.UUID(published_data["id"])
            is_valid_uuid = True
        except ValueError:
            is_valid_uuid = False
            
        assert is_valid_uuid, "Generated ID is not a valid UUID"

    @patch('google.cloud.pubsub_v1.PublisherClient')
    def test_user_provided_is_deleted_ignored(self, mock_publisher_class):
        """Test that user-provided 'is_deleted' field is ignored and set to False."""
        # Setup mock
        mock_publisher = mock_publisher_class.return_value
        mock_publisher.topic_path.return_value = "projects/test-project/topics/test-topic"
        
        mock_future = MagicMock()
        mock_future.result.return_value = "test-message-id"
        mock_publisher.publish.return_value = mock_future
        
        # Test with user trying to set is_deleted=True
        test_data = {**self.valid_base_data, "is_deleted": True}
        
        # Make API request
        response = client.post("/prices", json=[test_data])
        
        # Verify successful response
        assert response.status_code == 201
        
        # Verify the is_deleted field in Pub/Sub message is False (system default)
        publish_call = mock_publisher.publish.call_args
        published_data = json.loads(publish_call[0][1].decode('utf-8'))
        
        assert "is_deleted" in published_data
        assert published_data["is_deleted"] is False

    @patch('google.cloud.pubsub_v1.PublisherClient')
    def test_user_provided_insertion_timestamp_ignored(self, mock_publisher_class):
        """Test that user-provided 'insertion_timestamp' field is ignored and a new one is generated."""
        # Setup mock
        mock_publisher = mock_publisher_class.return_value
        mock_publisher.topic_path.return_value = "projects/test-project/topics/test-topic"
        
        mock_future = MagicMock()
        mock_future.result.return_value = "test-message-id"
        mock_publisher.publish.return_value = mock_future
        
        # User-provided insertion timestamp from the past
        user_insertion_timestamp = "2020-01-01T00:00:00Z"
        
        # Test with user trying to set insertion_timestamp
        test_data = {**self.valid_base_data, "insertion_timestamp": user_insertion_timestamp}
        
        # Make API request
        response = client.post("/prices", json=[test_data])
        
        # Verify successful response
        assert response.status_code == 201
        
        # Verify the insertion_timestamp in Pub/Sub message is not the user-provided one
        publish_call = mock_publisher.publish.call_args
        published_data = json.loads(publish_call[0][1].decode('utf-8'))
        
        assert "insertion_timestamp" in published_data
        assert published_data["insertion_timestamp"] != user_insertion_timestamp
        
        # Parse generated timestamp to verify it's recent
        try:
            generated_time = datetime.fromisoformat(published_data["insertion_timestamp"].replace('Z', '+00:00'))
            now = datetime.now(timezone.utc)
            time_diff = (now - generated_time).total_seconds()
            
            # Generated timestamp should be recent (within 10 seconds)
            assert time_diff < 10
        except ValueError:
            pytest.fail("Generated insertion_timestamp is not a valid ISO 8601 timestamp")

    def test_multiple_protected_fields(self):
        """Test multiple protected fields provided simultaneously."""
        with patch('google.cloud.pubsub_v1.PublisherClient') as mock_publisher_class:
            # Setup mock
            mock_publisher = mock_publisher_class.return_value
            mock_publisher.topic_path.return_value = "projects/test-project/topics/test-topic"
            
            mock_future = MagicMock()
            mock_future.result.return_value = "test-message-id"
            mock_publisher.publish.return_value = mock_future
            
            # Create test data with multiple protected fields
            test_data = {
                **self.valid_base_data,
                "id": "user-provided-id",
                "is_deleted": True,
                "insertion_timestamp": "2020-01-01T00:00:00Z"
            }
            
            # Make API request
            response = client.post("/prices", json=[test_data])
            
            # Verify successful response
            assert response.status_code == 201
            
            # Verify all protected fields were overridden
            publish_call = mock_publisher.publish.call_args
            published_data = json.loads(publish_call[0][1].decode('utf-8'))
            
            # ID should be a valid UUID, not user-provided
            assert published_data["id"] != "user-provided-id"
            
            # is_deleted should be False
            assert published_data["is_deleted"] is False
            
            # insertion_timestamp should be recent
            assert published_data["insertion_timestamp"] != "2020-01-01T00:00:00Z"

    def test_model_level_field_validation(self):
        """Test field validation at the Pydantic model level."""
        # First, test that PostData model excludes protected fields from user input
        test_input = {
            **self.valid_base_data,
            "id": "should-be-ignored",
            "is_deleted": True,
            "insertion_timestamp": "2020-01-01T00:00:00Z"
        }
        
        # Create model instance
        model = PostData(**test_input)
        
        # Verify that protected fields are not present or were not influenced by user input
        assert not hasattr(model, 'id'), "PostData should not have 'id' attribute from user input"
        assert not hasattr(model, 'is_deleted'), "PostData should not have 'is_deleted' attribute from user input"
        assert not hasattr(model, 'insertion_timestamp'), "PostData should not have 'insertion_timestamp' attribute from user input"
        
        # Next, check model dump to ensure protected fields are not included
        dumped_data = model.model_dump()
        assert 'id' not in dumped_data, "model_dump() should not include 'id'"
        assert 'is_deleted' not in dumped_data, "model_dump() should not include 'is_deleted'"
        assert 'insertion_timestamp' not in dumped_data, "model_dump() should not include 'insertion_timestamp'"


class TestInjectionPrevention:
    """Test prevention of code/SQL injection through protected fields."""

    def setup_method(self):
        """Setup for each test."""
        self.valid_base_data = {
            "crypto_name": "Bitcoin",
            "crypto_symbol": "BTC",
            "fiat_currency": "USD",
            "source": "test-api",
            "open": 50000.0,
            "close": 51000.0,
            "high": 52000.0,
            "low": 49000.0,
            "volume": 1000.0,
            "ticker": "BTC-USD",
            "timestamp": datetime.now(timezone.utc).isoformat()
        }

    @patch('google.cloud.pubsub_v1.PublisherClient')
    def test_sql_injection_in_id(self, mock_publisher_class):
        """Test handling of SQL injection attempts in the id field."""
        # Setup mock
        mock_publisher = mock_publisher_class.return_value
        mock_publisher.topic_path.return_value = "projects/test-project/topics/test-topic"
        
        mock_future = MagicMock()
        mock_future.result.return_value = "test-message-id"
        mock_publisher.publish.return_value = mock_future
        
        # SQL injection attempt in id
        sql_injection = "'; DROP TABLE users; --"
        test_data = {**self.valid_base_data, "id": sql_injection}
        
        # Make API request
        response = client.post("/prices", json=[test_data])
        
        # Verify successful response (should handle safely)
        assert response.status_code == 201
        
        # Check that the SQL injection attempt was not used
        publish_call = mock_publisher.publish.call_args
        published_data = json.loads(publish_call[0][1].decode('utf-8'))
        
        assert published_data["id"] != sql_injection

    @patch('google.cloud.pubsub_v1.PublisherClient')
    def test_script_injection_in_id(self, mock_publisher_class):
        """Test handling of script injection attempts in the id field."""
        # Setup mock
        mock_publisher = mock_publisher_class.return_value
        mock_publisher.topic_path.return_value = "projects/test-project/topics/test-topic"
        
        mock_future = MagicMock()
        mock_future.result.return_value = "test-message-id"
        mock_publisher.publish.return_value = mock_future
        
        # Script injection attempt in id
        script_injection = "<script>alert('XSS')</script>"
        test_data = {**self.valid_base_data, "id": script_injection}
        
        # Make API request
        response = client.post("/prices", json=[test_data])
        
        # Verify successful response (should handle safely)
        assert response.status_code == 201
        
        # Check that the script injection attempt was not used
        publish_call = mock_publisher.publish.call_args
        published_data = json.loads(publish_call[0][1].decode('utf-8'))
        
        assert published_data["id"] != script_injection


if __name__ == "__main__":
    pytest.main(["-xvs", "test_security_constraints.py"])
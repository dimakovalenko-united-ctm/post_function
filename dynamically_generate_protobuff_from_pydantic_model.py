#!/usr/bin/env python
from typing import Optional, get_origin, get_args, Union
from pydantic import BaseModel, Field, UUID4
from common.models.date_time_iso8601 import DateTime as DateTime
import subprocess
import os
from common.models.approved_uuid import ApprovedUUID as UUID

class OptionalFields(BaseModel):    
    dividends: Optional[float] = Field(None, description="Dividends")
    stock_splits: Optional[float] = Field(None, description="Stock Splits")        

class RequiredFields(BaseModel):    
    crypto_name: str = Field(..., description="Name of the Crypto Currency")
    crypto_symbol: str = Field(..., description="Symbol for the crypto currency")
    fiat_currency: str = Field(..., description="Currency the values stored in such as USD or EUR")
    source: str = Field(..., description="Source where the data was pulled from")
    open: float = Field(..., description="Open price")
    close: float = Field(..., description="Close price")
    high: float = Field(..., description="High price")
    low: float = Field(..., description="Low price")
    volume: float = Field(..., description="Volume")
    ticker: str = Field(..., description="Ticker used to look up the currency")

class AutoGeneratedFields(BaseModel):
    id: UUID = Field(..., description="UUID v4 of the inserted row")
    timestamp: DateTime = Field(..., description="ISO 8601 timestamp")
    is_deleted: Optional[bool] = Field(False, description="Soft delete flag (Default False)")

class DatabaseStructure(RequiredFields, AutoGeneratedFields, OptionalFields):
    pass

def generate_proto_from_pydantic(model: BaseModel, proto_file_name: str, output_dir: str = "."):
    """
    Generates a .proto file from a Pydantic model.
    
    Args:
        model (BaseModel): The Pydantic model to convert.
        proto_file_name (str): Name of the .proto file to generate.
        output_dir (str): Directory to write the .proto file and compiled output.
    """
    # Ensure the output directory exists
    os.makedirs(output_dir, exist_ok=True)

    proto_lines = ['syntax = "proto3";', f'message {model.__name__} {{']
    field_number = 1

    for field_name, field_info in model.model_fields.items():
        field_type = field_info.annotation
        proto_type = map_pydantic_to_proto(field_type)

        # Handle default values
        default_value = None
        if field_info.default is not None:
            default_value = field_info.default
        elif field_info.default_factory is not None:
            default_value = field_info.default_factory()

        field_line = f'  {proto_type} {field_name} = {field_number};'
        if default_value is not None:
            field_line += f' // Default: {default_value}'
        proto_lines.append(field_line)

        field_number += 1

    proto_lines.append('}')
    proto_content = '\n'.join(proto_lines)

    # Write the .proto file
    proto_file_path = os.path.join(output_dir, proto_file_name)
    with open(proto_file_path, 'w') as f:
        f.write(proto_content)

    # Compile the .proto file
    try:
        subprocess.run(['protoc', f'--python_out={output_dir}', proto_file_path], check=True)
    except FileNotFoundError:
        raise RuntimeError("The 'protoc' compiler is not installed or not in your PATH.")

def map_pydantic_to_proto(pydantic_type):
    """
    Maps Pydantic types to Protobuf types.
    
    Args:
        pydantic_type: The Pydantic type to map.
    
    Returns:
        str: The corresponding Protobuf type.
    """
    # Handle Optional types (e.g., Optional[float], Optional[str])
    origin = get_origin(pydantic_type)
    if origin is Optional or origin is Union and type(None) in get_args(pydantic_type):
        inner_type = next(arg for arg in get_args(pydantic_type) if arg is not type(None))
        return map_pydantic_to_proto(inner_type)

    # Handle primitive types
    if pydantic_type is float:
        return 'float'
    elif pydantic_type is str:
        return 'string'
    elif pydantic_type is bool:
        return 'bool'
    elif pydantic_type is int:
        return 'int32'
    elif pydantic_type is DateTime:
        return 'string'  # Assuming ISO-8601 format
    elif pydantic_type is UUID:
        return 'string'  # UUID is represented as a string in protobuf
    
    # Handle class types that might be coming from Pydantic v2
    if isinstance(pydantic_type, type):
        if issubclass(pydantic_type, UUID):
            return 'string'  # UUID is represented as a string in protobuf
        elif issubclass(pydantic_type, DateTime):
            return 'string'  # datetime as ISO-8601 string

    # Raise an error for unsupported types
    raise ValueError(f"Unsupported Pydantic type: {pydantic_type}")

# Generate the .proto file and compile it
if __name__ == "__main__":
    generate_proto_from_pydantic(DatabaseStructure, 'crypto_model.proto', output_dir="./output")